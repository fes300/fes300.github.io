<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>&lt;wiki&gt;</title>
  <link href='../../css/wiki.css' rel='stylesheet' type='text/css'></style>
  <link href='https://fonts.googleapis.com/css?family=Lobster|Inconsolata' rel='stylesheet' type='text/css'>
  <link rel="import" href="common/navbar.html">
</head>
<body>

  <nav-bar title="Wiki" subsections="Useful_git_commands, Useful_terminal_commands, JS_intro, rules_of_modules, boilerplate, CSS_intro, seven_one, oocss, enduringCSS, curring_functions, redux_saga"></nav-bar>
  <div class="space"></div>

  <div id="Useful_git_commands" class="wikiDiv">
    <h2>Useful git commands</h2>
    <ul>
      <li>After fetching, remove any remote-tracking branches which no longer exist on the remote:<p class="code">$ git fetch -p</p></li>
      <li>Delete local branch:<p class="code">$ git branch -d [the_local_branch_name]</p></li>
      <li>Delete remote branch:<p class="code">$ git push origin :[the_remote_branch_name]</p></li>
      <li>Let you decide on single hunks staging in the file:<p class="code">$ git add -patch [the_file_path_to_add]</p></li>
      <li>Force going back to remote master:<p class="code">$ git reset --hard</p></li>
      <li>Delete your last commit staged but not pushed:<p class="code">$ git reset --hard HEAD~1</p></li>
    </ul>
  </div>

  <div id="Useful_terminal_commands" class="wikiDiv">
    <h2>Useful terminal commands</h2>
    <ul>
      <li>Upgrade Oh-My-Zsh:<p class="code">$ ~/.oh-my-zsh</br>$ git stash</br>$ apt-get upgrade oh-my-zsh</br>$ git stash pop</p></li>
      <li>Check port status at an IP address from remote (need to install nmap):<p class="code">$ sudo nmap -A -O -vvv ip_address</p></li>
      <li>Check the process using a port:<p class="code">$ lsof -n -i4TCP:$PORT | grep LISTEN</p></li>
      <li>Check your external (router to out) IP address:<p class="code">$ wget http://ipinfo.io/ip -qO</p></li>
      <li>Check network status:<p class="code">$ lshw -C network</p></li>
      <li>Copy SSH to clipboard (need to install xclip):<p class="code">$ cat ~/.ssh/id_rsa.pub | xclip -selection clipboard</p></li>
    </ul>
  </div>

  <div id="JS_intro" class="wikiDiv">
    <h2>Intro</h2>
    <div>
      JS architecture needs to be modular in order to build complex scalable architectures that are easy to mantain.</br></br>
      Doing so allows for separate pieces of code to work independently with respect to one another, thus making them a lot easyer to debug and mantain.</br></br>
      Modern code architectures are experiencing a shift of the main logic from the backend services, which are increasingly designed as mere data dispensers communicating throug a restful API architecture, to the frontend.</br>
      The client side is evolving to adapt to this new logic and in order to address the new needs, increasigly elaborate frontend solutions saw the light in recent years (Backbone, Angular, React).</br></br>
      I will now try to make a very incomplete overview of the existing possibilities to structure your code in case you are going with one of these, in Particular I will focus on looking for a good pal for <strong>React - Redux</strong>.
    </div>
  </div>

  <div id="rules_of_modules" class="wikiDiv">
    <h2>Golden Rules</h2>
    There are a few rules you should follow in order to write consistent, clean modules that do not interfere with your architecture:
    <ul>
      <li>The 'sandbox' (interface to ensure <strong>loose coupling <span class="tooltip">a loosely coupled system is one in which each of its components has, or makes use of, little or no knowledge of the definitions of other separate components</span></strong>[reducers?]) is where the interaction with outer worls takes place, NOWERE ELSE!</li>
      <li>You must not access non native global objects inside a module.</li>
      <li>Only access DOM elements from the sandbox.</li>
      <li>Do not create global objects!</li>
      <li>Don't reference other modules!</li>
    </ul>
  </div>

  <div id="boilerplate" class="wikiDiv">
    <h2>Boilerplate</h2>
    <div>
      BoilerplateJS is a collection of product engineering patterns and some JavaScript libraries.</br>
      It relies on <strong>'Asynchronous Module Definition' <span class="tooltip">AMD, bacically an API reference (is the foundation of RequireJS)</span></strong>to define modules.
      It also implements some Object Oriented patterns/best-practices.</br></br>
      It does so trough the <span class="italic">"Boiler.Context"</span> class, a self contained and protected facade for all of the resource needs of a module which interact with other contexts in a controlled manner [basically a sandbox?].</br></br>
      The tipical structure for the UI in Boilerplate is:</br>
      <ul>
        <li>assets (folder, [img etc..])</li>
        <li>nls (folder, [locales])</li>
        <li>style.css</li>
        <li>view.html</li>
        <li>viewmodel.js (logic of the module [could be controller])</li>
        <li>component.js (encapsulate all of the above and communicate with the external world)</li>
      </ul>
      "Boiler.Context" exposes a pair of mediating methods 'listen' & 'notify' which enable components to interact,
      this looks like the Action Dispatcher in React Flux, with the difference that the logic is not isolated in a dispatcher but spread among components.</br>
      Boilerplate claims to be just an architecture reference that can integrate with other MVC libraries such as Backbone (altough I can't find a reason to use an MVC on top of it....).
    </div>
    <h2>My toughts</h2>
    <div>
      <ul>
        <li>Boilerplate could integrate well with Atomic Design as the Boiler.Context object is "nestable".</li>
        <li>Redux allows for higher modularity as communication between modules lies on an external sandbox (reducers) and not on specific methods of the <strong>module wrapper <span class="tooltip">seems to me that boilerplate is breaking a golden rule here...</span></strong>.</li>
        <li>Unit testing, client-side routing and a documentation tool are built in natively.</li>
      </ul>
      Overall it seems to me that Boilerplate is shipped with quite a lot of libraries and, altough it might be useful in some cases, most of these libraries might be unwanted.
      In the end, if I was to go with this, I woudn't use React nor Redux. It's a nice approach but, despite the makers claims, I don't think it would integrate well with other frameworks, adding to many layers and complexity.</br>
      I would thus go with the performance, one way data binding of React combined with one way data flow of Redux.
    </div>
  </div>

  <div id="CSS_intro" class="wikiDiv">
    <h2>Intro to CSS Architecture</h2>
    <div>
      Along the lines of JS architecture, CSS architecture also has to be modular if you don't want to end up with a 'boiling potato'.</br></br>
      There are many different (but somewhat similar) approaches to structure a scalable CSS library:
      <ul>
        <li>
          SMACCS
        </li>
        <li>
          Expressive CSS
        </li>
        <li>
          BEM
        </li>
        <li>
          7-1 Architecture
        </li>
        <li>
          OOCSS (Atomic CSS)
        </li>
      </ul>
    </div>
  </div>

  <div id="seven_one" class="wikiDiv">
    <h2>7-1</h2>
    7-1 Pattern is described in the official SASS documentation. Basically the 7-1 stands for 7 foldersw, 1 file.</br></br>
    The seven folders are:
    <ul class="italic">
      <li>base/</li>
      <li>components/</li>
      <li>layout/</li>
      <li>pages/</li>
      <li>themes/</li>
      <li>abstracts/</li>
      <li>vendors/</li>
    </ul>

    that are themselves structured as follows:
    <pre class="code">sass/
      |
      | abstracts/
      |   | _variables.scss    # Sass Variables
      |   | _functions.scss    # Sass Functions
      |   | _mixins.scss       # Sass Mixins
      |   | _placeholders.scss # Sass Placeholders
      |
      | base/
      |   | _reset.scss        # Reset/normalize
      |   | _typography.scss   # Typography rules
      |
      | components/
      |   | _buttons.scss      # Buttons
      |   | _carousel.scss     # Carousel
      |   | _cover.scss        # Cover
      |   | _dropdown.scss     # Dropdown
      |
      | layout/
      |   | _navigation.scss   # Navigation
      |   | _grid.scss         # Grid system
      |   | _header.scss       # Header
      |   | _footer.scss       # Footer
      |   | _sidebar.scss      # Sidebar
      |   | _forms.scss        # Forms
      |
      | pages/
      |   | _home.scss         # Home specific styles
      |   | _contact.scss      # Contact specific styles
      |
      | themes/
      |   | _theme.scss        # Default theme
      |   | _admin.scss        # Admin theme
      |
      | vendors/
      |   | _bootstrap.scss    # Bootstrap
      |   | _jquery-ui.scss    # jQuery UI
      |

    </pre>

    <p>And the single file:</p>
    <ul>
      <li>main.scss</li>
    </ul>
    <h2>My toughts</h2>
    This approach is a little less modular compared to Atomic design, as some of the folders are there to serve more general parts of the UI; you might say that components need to be aware of the layout styling. A more helpful approach would be (in my humble opinion) to discard those folders and keep the shared styling (if there ever is one) in the abstracts folder.
  </div>

  <div id="oocss" class="wikiDiv">
    <h2>OOCSS</h2>
    <div>
    </div>
  </div>

  <div id="enduringCSS" class="wikiDiv">
    <h2>Enduring CSS</h2>
    <div>
      The <strong>Enduring CSS approach<span class="tooltip">By Ben Fraim (https://benfrain.com/enduring-css-writing-style-sheets-rapidly-changing-long-lived-projects/)</span></strong> states that a preprocessor such as SASS and the following features are essential for a mature CSS codebase:
      <ul>
        <li>variables (to mitigate human errors with colour picking and specifying constants like grid measures)</li>
        <li>fragment/partials of styles (to facilitate one-to-one parity with a feature branch or template)</li>
        <li>basic mathematic operations (to negate reliance on ‘magic’ numbers)</li>
        <li>colour manipulations (to allow consistent manipulation of the aforementioned variables)</li>
      </ul>
    </div>
  </div>

  <div id="curring_functions" class="wikiDiv">
    <h2>Curring functions</h2>
    <div>
      Curried functions come from <span class="italic">functional JavaScript</span>, which aims to be shorter, tighter and getting to the point in the fewest lines possible with less repetition.</br></br>
      Basically currying is a way of constructing functions that allows partial application of a function’s arguments. What this means is that you can pass all of the arguments a function is expecting and get the result, or pass a subset of those arguments and get a function back that’s waiting for the rest of the arguments.</br>
      Currying is elemental in languages such as Haskell and Scala, which are built around functional concepts.</br></br>
      Easy example:</br>
      <pre class="code">
var greetCurried = greeting => name => {
  `${greeting}, ${name}`
}
      </pre></br>
      This function can be called like this:</br>
      <pre class="code">
greetCurried("Hi there")("Howard"); //"Hi there, Howard"
      </pre>
      To transform a non curried function into a curried one you can use:</br>
      <pre class="code">
var curryIt = uncurried => {
  let parameters = Array.prototype.slice.call(arguments, 1)
  return () => {
    uncurried.apply(this, parameters.concat(
      Array.prototype.slice.call(arguments, 0)
    ))
  }
}
      </pre>

    </div>
  </div>

  <div id="redux_saga" class="wikiDiv">
    <h2>Redux Saga</h2>
    <div>
      With sagas the application logic lives in 2 places:
      <ul>
        <li>Reducers are responsible for handling state transitions between actions.</li>
        <li>Sagas are responsible for orchestrating complex/asynchronous operations.</li>
      </ul>
      Sagas are created using <strong>Generator functions <span class="tooltip"><a href="https://davidwalsh.name/es6-generators">https://davidwalsh.name/es6-generators</a></span></strong>
      and are fired only once at the start of the application (but startup Sagas may fire other Sagas dynamically).
      They can be seen as Processes running in the background. Sagas watch the actions dispatched to the Store, then decide what to do based on dispatched actions:
      Either making an asynchronous call (like an AJAX request), dispatching other actions to the Store, or even starting other Sagas dynamically.
      This is achieved by yelding JavaScript Objects containing instructions to be executed by the Saga middleware. Tasks started in redux-saga can be cancelled at any moment either manually or automatically by putting them in a race with other Effects.


    </div>
  </div>

  <script type="text/javascript">
    'use strict'
    document.addEventListener("DOMContentLoaded", (event) => {
      let h = screen.height + window.innerHeight;
      document.body.style.height = `${h}px`;
      document.body.style.background = 'linear-gradient(to bottom, white 30%, rgba(0,0,0,.7)) no-repeat';
      document.body.style.backgroundAttachment = 'fixed';
      document.body.style.margin = 0;
    });
  </script>
</body>
</html>
