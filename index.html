<!DOCTYPE html>
<html>
<head>
  <title>JS architecture</title>
</head>

<header>
  <link href='https://fonts.googleapis.com/css?family=Lobster|Inconsolata' rel='stylesheet' type='text/css'>
  <link href='css.css' rel='stylesheet' type='text/css'></style>
</header>
<body>
  <div id="title">
    <h1>JS arichitecture</h1>
  </div>
  <div class="menu">
    <h2 class="menu-item" target="intro">Intro & general </br>thoughts</h2>
    <h2 class="menu-item" target="rules-of-modules">Modules golden </br>rules</h2>
    <h2 class="menu-item" target="boilerplate">Boilerplate JS</h2>
  </div>
  <div id="sectionsContainer">
    <div id="intro" class="item first-item">
      <h2>Intro</h2>
      <div>
        JS architecture has to be seen as modular in order to build complex scalable architectures that are easy to mantain.</br></br>
        Doing so allows for separate pieces of code to work independently with respect to one another, thus making them a lot easyer to debug and mantain.</br></br>
        Modern code architectures are experiencing a shift of the "home" of the main logic from the backend services, which are increasingly designed as mere data dispensers communicating throug a restful API architecture, to the frontend.</br></br>
        The client side is evolving to adapt to this new logic and increasigly elaborate frontend solutions saw the light in recent years to address the need (Backbone, Angular, React).</br></br>
        I will now try to make a very incomplete overview of the existing possibilities to structure your code in case you are going with one of these, in Particular I will focus on looking for a good pal for <strong>React - Redux</strong>.
      </div>
    </div>
    <div id="rules-of-modules" class="item">
      <h2>Golden Rules</h2>
      There are a few rules you should follow in order to write consistent clean modules that do not interfere with your architecture:
      <ul>
        <li>The 'sandbox' (interface to ensure <strong>loose coupling <span class="tooltip">a loosely coupled system is one in which each of its components has, or makes use of, little or no knowledge of the definitions of other separate components</span></strong>[reducers?]) is where the interaction with outer worls takes place, NOWERE ELSE!</li>
        <li>You must not access non native global objects inside a module.</li>
        <li>Only access DOM elements from the sandbox.</li>
        <li>Do not create global objects!</li>
        <li>Don't reference other modules!</li>
      </ul>
    </div>
    <div id="boilerplate" class="item">
      <h2>Boilerplate</h2>
      <div>
        BoilerplateJS is a collection of product engineering patterns and some JavaScript libraries.</br>
        It relies on <strong>'Asynchronous Module Definition' <span class="tooltip">AMD, bacically an API reference (is the foundation of RequireJS)</span></strong>to define modules.
        It also implements some Object Oriented patterns/best-practices.</br></br>
        It does so trough the <span class="italic">"Boiler.Context"</span> class, a self contained and protected facade for all of the resource needs of a module which interact with other contexts in a controlled manner [basically a sandbox?].</br></br>
        The tipical structure for the UI in Boilerplate is:</br>
        <ul>
          <li>assets (folder, [img etc..])</li>
          <li>nls (folder, [locales])</li>
          <li>style.css</li>
          <li>view.html</li>
          <li>viewmodel.js (logic of the module [could be controller])</li>
          <li>component.js (encapsulate all of the above and communicate with the external world)</li>
        </ul>
        "Boiler.Context" exposes a pair of mediating methods 'listen' & 'notify' which enable components to interact,
        this looks like the Action Dispatcher in React Flux, with the difference that the logic is not isolated in a dispatcher but spread among components.</br>
        Boilerplate claims to be just an architecture reference that can integrate with other MVC libraries such as Backbone (altough I can't find a reason to use an MVC on top of it....).
      </div>
      <h2>My toughts</h2>
      <div>
        <ul>
          <li>Boilerplate could integrate well with Atomic Design as the Boiler.Context object is "nestable".</li>
          <li>Redux allows for higher modularity as communication between modules lies on an external sandbox (reducers) and not on specific methods of the <strong>module wrapper <span class="tooltip">seems to me that boilerplate is breaking a golden rule here...</span></strong>.</li>
          <li>Unit testing, client-side routing and a documentation tool are built in natively.</li>
        </ul>
        Overall it seems to me that Boilerplate is shipped with quite a lot of libraries and, altough it might be useful in some cases, most of these libraries might be unwanted.
        In the end, if I was to go with this, I woudn't use React nor Redux. It's a nice approach but, despite the makers claims, I don't think it would integrate well with other frameworks, adding to many layers and complexity.</br>
        I would thus go with the performance, one way data binding of React combined with one way data flow of Redux.
      </div>
    </div>
  </div>

  <script>
    'use strict';

    let menu_items = document.querySelectorAll('.menu-item');
    Array.prototype.forEach.call(menu_items, mi=>{
      mi.addEventListener('click', (e)=>{
        Array.prototype.forEach.call(menu_items, mi=>{
          mi.classList.remove('active');
        });
        e.target.classList.add('active');
        let item = document.querySelector(`#${e.target.getAttribute('target')}`),
        children = item.parentNode.children;
        Array.prototype.forEach.call(children, i=>{
          i.classList.remove('show-item');
          i.classList.remove('first-item');
        });
        item.classList.add('show-item');
      })
    })
  </script>
</body>
